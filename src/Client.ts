/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as stream from "stream";
import urlJoin from "url-join";
import * as Vectara from "./api/index";
import { ApiKeys } from "./api/resources/apiKeys/client/Client";
import { AppClients } from "./api/resources/appClients/client/Client";
import { Auth } from "./api/resources/auth/client/Client";
import { Chats } from "./api/resources/chats/client/Client";
import { Corpora } from "./api/resources/corpora/client/Client";
import { Documents } from "./api/resources/documents/client/Client";
import { Encoders } from "./api/resources/encoders/client/Client";
import { GenerationPresets } from "./api/resources/generationPresets/client/Client";
import { Index } from "./api/resources/index/client/Client";
import { Jobs } from "./api/resources/jobs/client/Client";
import { Llms } from "./api/resources/llms/client/Client";
import { QueryHistory } from "./api/resources/queryHistory/client/Client";
import { Rerankers } from "./api/resources/rerankers/client/Client";
import { Upload } from "./api/resources/upload/client/Client";
import { Users } from "./api/resources/users/client/Client";
import * as core from "./core";
import * as environments from "./environments";
import * as errors from "./errors/index";
import * as serializers from "./serialization/index";

export declare namespace VectaraClient {
    interface Options {
        environment?: core.Supplier<environments.VectaraEnvironment | environments.VectaraEnvironmentUrls>;
        clientId?: core.Supplier<string>;
        clientSecret?: core.Supplier<string>;
        /** Override the x-api-key header */
        apiKey?: core.Supplier<string | undefined>;
        fetcher?: core.FetchFunction;
    }

    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the x-api-key header */
        apiKey?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}

export class VectaraClient {
    private readonly _oauthTokenProvider: core.OAuthTokenProvider;
    protected _corpora: Corpora | undefined;
    protected _upload: Upload | undefined;
    protected _documents: Documents | undefined;
    protected _index: Index | undefined;
    protected _chats: Chats | undefined;
    protected _llms: Llms | undefined;
    protected _generationPresets: GenerationPresets | undefined;
    protected _encoders: Encoders | undefined;
    protected _rerankers: Rerankers | undefined;
    protected _jobs: Jobs | undefined;
    protected _users: Users | undefined;
    protected _apiKeys: ApiKeys | undefined;
    protected _appClients: AppClients | undefined;
    protected _queryHistory: QueryHistory | undefined;
    protected _auth: Auth | undefined;

    constructor(protected readonly _options: VectaraClient.Options = {}) {
        const clientId = this._options.clientId ?? process.env["VECTARA_CLIENT_ID"];
        if (clientId == null) {
            throw new Error(
                "clientId is required; either pass it as an argument or set the VECTARA_CLIENT_ID environment variable"
            );
        }

        const clientSecret = this._options.clientSecret ?? process.env["VECTARA_CLIENT_SECRET"];
        if (clientSecret == null) {
            throw new Error(
                "clientSecret is required; either pass it as an argument or set the VECTARA_CLIENT_SECRET environment variable"
            );
        }

        this._oauthTokenProvider = new core.OAuthTokenProvider({
            clientId,
            clientSecret,
            authClient: new Auth({
                environment: this._options.environment,
            }),
        });
    }

    public get corpora(): Corpora {
        return (this._corpora ??= new Corpora({
            ...this._options,
            token: async () => await this._oauthTokenProvider.getToken(),
        }));
    }

    public get upload(): Upload {
        return (this._upload ??= new Upload({
            ...this._options,
            token: async () => await this._oauthTokenProvider.getToken(),
        }));
    }

    public get documents(): Documents {
        return (this._documents ??= new Documents({
            ...this._options,
            token: async () => await this._oauthTokenProvider.getToken(),
        }));
    }

    public get index(): Index {
        return (this._index ??= new Index({
            ...this._options,
            token: async () => await this._oauthTokenProvider.getToken(),
        }));
    }

    public get chats(): Chats {
        return (this._chats ??= new Chats({
            ...this._options,
            token: async () => await this._oauthTokenProvider.getToken(),
        }));
    }

    public get llms(): Llms {
        return (this._llms ??= new Llms({
            ...this._options,
            token: async () => await this._oauthTokenProvider.getToken(),
        }));
    }

    public get generationPresets(): GenerationPresets {
        return (this._generationPresets ??= new GenerationPresets({
            ...this._options,
            token: async () => await this._oauthTokenProvider.getToken(),
        }));
    }

    public get encoders(): Encoders {
        return (this._encoders ??= new Encoders({
            ...this._options,
            token: async () => await this._oauthTokenProvider.getToken(),
        }));
    }

    public get rerankers(): Rerankers {
        return (this._rerankers ??= new Rerankers({
            ...this._options,
            token: async () => await this._oauthTokenProvider.getToken(),
        }));
    }

    public get jobs(): Jobs {
        return (this._jobs ??= new Jobs({
            ...this._options,
            token: async () => await this._oauthTokenProvider.getToken(),
        }));
    }

    public get users(): Users {
        return (this._users ??= new Users({
            ...this._options,
            token: async () => await this._oauthTokenProvider.getToken(),
        }));
    }

    public get apiKeys(): ApiKeys {
        return (this._apiKeys ??= new ApiKeys({
            ...this._options,
            token: async () => await this._oauthTokenProvider.getToken(),
        }));
    }

    public get appClients(): AppClients {
        return (this._appClients ??= new AppClients({
            ...this._options,
            token: async () => await this._oauthTokenProvider.getToken(),
        }));
    }

    public get queryHistory(): QueryHistory {
        return (this._queryHistory ??= new QueryHistory({
            ...this._options,
            token: async () => await this._oauthTokenProvider.getToken(),
        }));
    }

    public get auth(): Auth {
        return (this._auth ??= new Auth({
            ...this._options,
            token: async () => await this._oauthTokenProvider.getToken(),
        }));
    }

    /**
     * Perform a multipurpose query across to retrieve relevant information from one or more corpora and generate a response using Retrieval Augmented Generation (RAG).
     *
     * * Specify the unique `corpus_key` identifying the corpus to query. The `corpus_key` is [created in the Vectara Console UI](https://docs.vectara.com/docs/console-ui/creating-a-corpus) or the [Create Corpus API definition](https://docs.vectara.com/docs/api-reference/admin-apis/create-corpus). When creating a new corpus, you have the option to assign a custom `corpus_key` following your preferred naming convention. This key serves as a unique identifier for the corpus, allowing it to be referenced in search requests. For more information, see [Corpus Key Definition](https://docs.vectara.com/docs/api-reference/search-apis/search#corpus-key-definition).
     * * Customize your search by specifying the query text (`query`), pagination details (`offset` and `limit`), and metadata filters (`metadata_filter`) to tailor your search results. [Learn more](https://docs.vectara.com/docs/api-reference/search-apis/search#query-definition)
     * * Leverage advanced search capabilities like reranking (`reranker`) and opt-in Retrieval Augmented Generation (RAG) (`generation`) for enhanced query performance. Generation is opt in by setting the `generation` property. By excluding the property or by setting it to null, the response
     * will not include generation. [Learn more](https://docs.vectara.com/docs/learn/grounded-generation/configure-query-summarization)
     * * Specify Vectara's RAG-focused LLM (Mockingbird) for the `generation_preset_name`. [Learn more](https://docs.vectara.com/docs/learn/mockingbird-llm)
     * * Use advanced summarization options that utilize detailed summarization parameters such as `max_response_characters`, `temperature`, and `frequency_penalty` for generating precise and relevant summaries. [Learn more](https://docs.vectara.com/docs/api-reference/search-apis/search#advanced-summarization-customization-options)
     * * Customize citation formats in summaries using the `citations` object to include numeric, HTML, or Markdown links. [Learn more](https://docs.vectara.com/docs/api-reference/search-apis/search#citation-format-in-summary)
     *
     * For more detailed information, see this [Query API guide](https://docs.vectara.com/docs/api-reference/search-apis/search).
     */
    public async queryStream(
        request: Vectara.QueryStreamRequest,
        requestOptions?: VectaraClient.RequestOptions
    ): Promise<core.Stream<Vectara.QueryStreamedResponse>> {
        const { requestTimeout, requestTimeoutMillis, ..._body } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)<stream.Readable>({
            url: urlJoin(
                ((await core.Supplier.get(this._options.environment)) ?? environments.VectaraEnvironment.Production)
                    .default,
                "v2/query"
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-api-key":
                    (await core.Supplier.get(this._options.apiKey)) != null
                        ? await core.Supplier.get(this._options.apiKey)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "vectara",
                "X-Fern-SDK-Version": "0.1.5",
                "User-Agent": "vectara/0.1.5",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                "Request-Timeout": requestTimeout != null ? requestTimeout.toString() : undefined,
                "Request-Timeout-Millis": requestTimeoutMillis != null ? requestTimeoutMillis.toString() : undefined,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: {
                ...serializers.QueryStreamRequest.jsonOrThrow(_body, { unrecognizedObjectKeys: "strip" }),
                stream_response: true,
            },
            responseType: "sse",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return new core.Stream({
                stream: _response.body,
                parse: async (data) => {
                    return serializers.QueryStreamedResponse.parseOrThrow(data, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        skipValidation: true,
                        breadcrumbsPrefix: ["response"],
                    });
                },
                signal: requestOptions?.abortSignal,
                eventShape: {
                    type: "sse",
                    streamTerminator: "[DONE]",
                },
            });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Vectara.BadRequestError(
                        serializers.BadRequestErrorBody.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        })
                    );
                case 403:
                    throw new Vectara.ForbiddenError(
                        serializers.Error_.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        })
                    );
                case 404:
                    throw new Vectara.NotFoundError(
                        serializers.NotFoundErrorBody.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        })
                    );
                default:
                    throw new errors.VectaraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.VectaraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.VectaraTimeoutError("Timeout exceeded when calling POST /v2/query.");
            case "unknown":
                throw new errors.VectaraError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Perform a multipurpose query across to retrieve relevant information from one or more corpora and generate a response using Retrieval Augmented Generation (RAG).
     *
     * * Specify the unique `corpus_key` identifying the corpus to query. The `corpus_key` is [created in the Vectara Console UI](https://docs.vectara.com/docs/console-ui/creating-a-corpus) or the [Create Corpus API definition](https://docs.vectara.com/docs/api-reference/admin-apis/create-corpus). When creating a new corpus, you have the option to assign a custom `corpus_key` following your preferred naming convention. This key serves as a unique identifier for the corpus, allowing it to be referenced in search requests. For more information, see [Corpus Key Definition](https://docs.vectara.com/docs/api-reference/search-apis/search#corpus-key-definition).
     * * Customize your search by specifying the query text (`query`), pagination details (`offset` and `limit`), and metadata filters (`metadata_filter`) to tailor your search results. [Learn more](https://docs.vectara.com/docs/api-reference/search-apis/search#query-definition)
     * * Leverage advanced search capabilities like reranking (`reranker`) and opt-in Retrieval Augmented Generation (RAG) (`generation`) for enhanced query performance. Generation is opt in by setting the `generation` property. By excluding the property or by setting it to null, the response
     * will not include generation. [Learn more](https://docs.vectara.com/docs/learn/grounded-generation/configure-query-summarization)
     * * Specify Vectara's RAG-focused LLM (Mockingbird) for the `generation_preset_name`. [Learn more](https://docs.vectara.com/docs/learn/mockingbird-llm)
     * * Use advanced summarization options that utilize detailed summarization parameters such as `max_response_characters`, `temperature`, and `frequency_penalty` for generating precise and relevant summaries. [Learn more](https://docs.vectara.com/docs/api-reference/search-apis/search#advanced-summarization-customization-options)
     * * Customize citation formats in summaries using the `citations` object to include numeric, HTML, or Markdown links. [Learn more](https://docs.vectara.com/docs/api-reference/search-apis/search#citation-format-in-summary)
     *
     * For more detailed information, see this [Query API guide](https://docs.vectara.com/docs/api-reference/search-apis/search).
     *
     * @param {Vectara.QueryRequest} request
     * @param {VectaraClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vectara.BadRequestError}
     * @throws {@link Vectara.ForbiddenError}
     * @throws {@link Vectara.NotFoundError}
     *
     * @example
     *     await client.query({
     *         query: "What is a hallucination?",
     *         search: {
     *             corpora: [{
     *                     corpusKey: "corpus_key",
     *                     metadataFilter: "",
     *                     lexicalInterpolation: 0.005
     *                 }],
     *             contextConfiguration: {
     *                 sentencesBefore: 2,
     *                 sentencesAfter: 2
     *             },
     *             reranker: {
     *                 type: "customer_reranker",
     *                 rerankerId: "rnk_272725719"
     *             }
     *         },
     *         generation: {
     *             responseLanguage: "eng",
     *             enableFactualConsistencyScore: true
     *         }
     *     })
     */
    public async query(
        request: Vectara.QueryRequest,
        requestOptions?: VectaraClient.RequestOptions
    ): Promise<Vectara.QueryFullResponse> {
        const { requestTimeout, requestTimeoutMillis, ..._body } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                ((await core.Supplier.get(this._options.environment)) ?? environments.VectaraEnvironment.Production)
                    .default,
                "v2/query"
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-api-key":
                    (await core.Supplier.get(this._options.apiKey)) != null
                        ? await core.Supplier.get(this._options.apiKey)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "vectara",
                "X-Fern-SDK-Version": "0.1.5",
                "User-Agent": "vectara/0.1.5",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                "Request-Timeout": requestTimeout != null ? requestTimeout.toString() : undefined,
                "Request-Timeout-Millis": requestTimeoutMillis != null ? requestTimeoutMillis.toString() : undefined,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: {
                ...serializers.QueryRequest.jsonOrThrow(_body, { unrecognizedObjectKeys: "strip" }),
                stream_response: false,
            },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return serializers.QueryFullResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                skipValidation: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Vectara.BadRequestError(
                        serializers.BadRequestErrorBody.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        })
                    );
                case 403:
                    throw new Vectara.ForbiddenError(
                        serializers.Error_.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        })
                    );
                case 404:
                    throw new Vectara.NotFoundError(
                        serializers.NotFoundErrorBody.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        })
                    );
                default:
                    throw new errors.VectaraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.VectaraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.VectaraTimeoutError("Timeout exceeded when calling POST /v2/query.");
            case "unknown":
                throw new errors.VectaraError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Create a chat while specifying the default retrieval parameters used by the prompt.
     */
    public async chatStream(
        request: Vectara.ChatStreamRequest,
        requestOptions?: VectaraClient.RequestOptions
    ): Promise<core.Stream<Vectara.ChatStreamedResponse>> {
        const { requestTimeout, requestTimeoutMillis, ..._body } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)<stream.Readable>({
            url: urlJoin(
                ((await core.Supplier.get(this._options.environment)) ?? environments.VectaraEnvironment.Production)
                    .default,
                "v2/chats"
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-api-key":
                    (await core.Supplier.get(this._options.apiKey)) != null
                        ? await core.Supplier.get(this._options.apiKey)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "vectara",
                "X-Fern-SDK-Version": "0.1.5",
                "User-Agent": "vectara/0.1.5",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                "Request-Timeout": requestTimeout != null ? requestTimeout.toString() : undefined,
                "Request-Timeout-Millis": requestTimeoutMillis != null ? requestTimeoutMillis.toString() : undefined,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: {
                ...serializers.ChatStreamRequest.jsonOrThrow(_body, { unrecognizedObjectKeys: "strip" }),
                stream_response: true,
            },
            responseType: "sse",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return new core.Stream({
                stream: _response.body,
                parse: async (data) => {
                    return serializers.ChatStreamedResponse.parseOrThrow(data, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                        skipValidation: true,
                        breadcrumbsPrefix: ["response"],
                    });
                },
                signal: requestOptions?.abortSignal,
                eventShape: {
                    type: "sse",
                    streamTerminator: "[DONE]",
                },
            });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Vectara.BadRequestError(
                        serializers.BadRequestErrorBody.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        })
                    );
                case 403:
                    throw new Vectara.ForbiddenError(
                        serializers.Error_.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        })
                    );
                case 404:
                    throw new Vectara.NotFoundError(
                        serializers.NotFoundErrorBody.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        })
                    );
                default:
                    throw new errors.VectaraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.VectaraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.VectaraTimeoutError("Timeout exceeded when calling POST /v2/chats.");
            case "unknown":
                throw new errors.VectaraError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Create a chat while specifying the default retrieval parameters used by the prompt.
     *
     * @param {Vectara.ChatRequest} request
     * @param {VectaraClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vectara.BadRequestError}
     * @throws {@link Vectara.ForbiddenError}
     * @throws {@link Vectara.NotFoundError}
     *
     * @example
     *     await client.chat({
     *         query: "What is a hallucination?",
     *         search: {
     *             corpora: [{
     *                     corpusKey: "corpus_key",
     *                     metadataFilter: "",
     *                     lexicalInterpolation: 0.005
     *                 }],
     *             contextConfiguration: {
     *                 sentencesBefore: 2,
     *                 sentencesAfter: 2
     *             },
     *             reranker: {
     *                 type: "customer_reranker",
     *                 rerankerId: "rnk_272725719"
     *             }
     *         },
     *         generation: {
     *             responseLanguage: "eng",
     *             enableFactualConsistencyScore: true,
     *             citations: {
     *                 style: "none"
     *             }
     *         },
     *         chat: {
     *             store: true
     *         }
     *     })
     */
    public async chat(
        request: Vectara.ChatRequest,
        requestOptions?: VectaraClient.RequestOptions
    ): Promise<Vectara.ChatFullResponse> {
        const { requestTimeout, requestTimeoutMillis, ..._body } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                ((await core.Supplier.get(this._options.environment)) ?? environments.VectaraEnvironment.Production)
                    .default,
                "v2/chats"
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "x-api-key":
                    (await core.Supplier.get(this._options.apiKey)) != null
                        ? await core.Supplier.get(this._options.apiKey)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "vectara",
                "X-Fern-SDK-Version": "0.1.5",
                "User-Agent": "vectara/0.1.5",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                "Request-Timeout": requestTimeout != null ? requestTimeout.toString() : undefined,
                "Request-Timeout-Millis": requestTimeoutMillis != null ? requestTimeoutMillis.toString() : undefined,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: {
                ...serializers.ChatRequest.jsonOrThrow(_body, { unrecognizedObjectKeys: "strip" }),
                stream_response: false,
            },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return serializers.ChatFullResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                skipValidation: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Vectara.BadRequestError(
                        serializers.BadRequestErrorBody.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        })
                    );
                case 403:
                    throw new Vectara.ForbiddenError(
                        serializers.Error_.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        })
                    );
                case 404:
                    throw new Vectara.NotFoundError(
                        serializers.NotFoundErrorBody.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        })
                    );
                default:
                    throw new errors.VectaraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.VectaraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.VectaraTimeoutError("Timeout exceeded when calling POST /v2/chats.");
            case "unknown":
                throw new errors.VectaraError({
                    message: _response.error.errorMessage,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = await this._oauthTokenProvider.getToken();
        if (bearer != null) {
            return `Bearer ${bearer}`;
        }

        return undefined;
    }
}
