/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Vectara from "../../../index.js";
import * as fs from "fs";
import { toJson } from "../../../../core/json.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";

export declare namespace Upload {
    export interface Options {
        environment?: core.Supplier<environments.VectaraEnvironment | environments.VectaraEnvironmentUrls>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token?: core.Supplier<core.BearerToken | undefined>;
        /** Override the x-api-key header */
        apiKey?: core.Supplier<string | undefined>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the x-api-key header */
        apiKey?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

/**
 * Upload files to a corpus for automatic parsing, text extraction, chunking, and indexing
 */
export class Upload {
    protected readonly _options: Upload.Options;

    constructor(_options: Upload.Options = {}) {
        this._options = _options;
    }

    /**
     * Upload files such as PDFs and Word Documents for automatic text extraction and metadata parsing.
     *
     * The request expects a `multipart/form-data` format containing the following parts:
     * * `metadata` - Optionally specifies a JSON object representing any additional metadata to be associated with the extracted document. For example, `''metadata={\"key\": \"value\"};type=application/json''`
     * * `chunking_strategy` - If provided, specifies the chunking strategy for the platform to use. If you do not set this option, the platform uses the default strategy, which creates one chunk per sentence. You can explicitly set sentence chunking with `''chunking_strategy={\"type\":\"sentence_chunking_strategy\"};type=application/json''` or use max chars chunking with `''chunking_strategy={\"type\":\"max_chars_chunking_strategy\",\"max_chars_per_chunk\":200};type=application/json''`
     * * `table_extraction_config` - You can optionally specify whether to extract table data from the uploaded file. If you do not set this option, the platform does not extract tables from PDF files. Example config, `''table_extraction_config={\"extract_tables\":true};type=application/json''` \n* `file` - Specifies the file that you want to upload. * `filename` - Specified as part of the file field with the file name that you want to associate with the uploaded file. For a curl example, use the following syntax: `''file=@/path/to/file/file.pdf;filename=desired_filename.pdf''`\n\nFor more detailed information, see this [File Upload API guide.](https://docs.vectara.com/docs/api-reference/indexing-apis/file-upload/file-upload)"
     *
     * @param {Vectara.CorpusKey} corpusKey
     * @param {Vectara.UploadFileRequest} request
     * @param {Upload.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Vectara.BadRequestError}
     * @throws {@link Vectara.ForbiddenError}
     * @throws {@link Vectara.NotFoundError}
     * @throws {@link Vectara.UnsupportedMediaTypeError}
     *
     * @example
     *     import { createReadStream } from "fs";
     *     await client.upload.file("my-corpus", {
     *         file: fs.createReadStream("/path/to/your/file")
     *     })
     */
    public file(
        corpusKey: Vectara.CorpusKey,
        request: Vectara.UploadFileRequest,
        requestOptions?: Upload.RequestOptions,
    ): core.HttpResponsePromise<Vectara.Document> {
        return core.HttpResponsePromise.fromPromise(this.__file(corpusKey, request, requestOptions));
    }

    private async __file(
        corpusKey: Vectara.CorpusKey,
        request: Vectara.UploadFileRequest,
        requestOptions?: Upload.RequestOptions,
    ): Promise<core.WithRawResponse<Vectara.Document>> {
        const _request = await core.newFormData();
        if (request.metadata != null) {
            _request.append("metadata", toJson(request.metadata));
        }

        if (request.chunking_strategy != null) {
            _request.append("chunking_strategy", toJson(request.chunking_strategy));
        }

        if (request.table_extraction_config != null) {
            _request.append("table_extraction_config", toJson(request.table_extraction_config));
        }

        if (request.filename != null) {
            _request.append("filename", request.filename);
        }

        await _request.appendFile("file", request.file);
        const _maybeEncodedRequest = await _request.getRequest();
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    ((await core.Supplier.get(this._options.environment)) ?? environments.VectaraEnvironment.Production)
                        .default,
                `v2/corpora/${encodeURIComponent(corpusKey)}/upload_file`,
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Request-Timeout":
                        request.Request - Timeout != null ? request.Request - Timeout.toString() : undefined,
                    "Request-Timeout-Millis":
                        request.Request - Timeout - Millis != null
                            ? request.Request - Timeout - Millis.toString()
                            : undefined,
                    "x-api-key": requestOptions?.apiKey,
                    ..._maybeEncodedRequest.headers,
                }),
                requestOptions?.headers,
            ),
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Vectara.Document, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Vectara.BadRequestError(
                        _response.error.body as Vectara.BadRequestErrorBody,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Vectara.ForbiddenError(_response.error.body as Vectara.Error_, _response.rawResponse);
                case 404:
                    throw new Vectara.NotFoundError(
                        _response.error.body as Vectara.NotFoundErrorBody,
                        _response.rawResponse,
                    );
                case 415:
                    throw new Vectara.UnsupportedMediaTypeError(
                        _response.error.body as Vectara.Error_,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.VectaraError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.VectaraError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.VectaraTimeoutError(
                    "Timeout exceeded when calling POST /v2/corpora/{corpus_key}/upload_file.",
                );
            case "unknown":
                throw new errors.VectaraError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = await core.Supplier.get(this._options.token);
        if (bearer != null) {
            return `Bearer ${bearer}`;
        }

        return undefined;
    }
}
